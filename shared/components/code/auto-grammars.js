// AUTOGENERATED FROM edb.edgeql.parser.grammar.keywords.
//
// USE make regen-grammar TO REGENERATE


var reserved_keywords = [
  "__edgedbsys__",
  "__edgedbtpl__",
  "__new__",
  "__old__",
  "__source__",
  "__specified__",
  "__std__",
  "__subject__",
  "__type__",
  "administer",
  "alter",
  "analyze",
  "and",
  "anyarray",
  "anyobject",
  "anytuple",
  "anytype",
  "begin",
  "by",
  "case",
  "check",
  "commit",
  "configure",
  "create",
  "deallocate",
  "delete",
  "describe",
  "detached",
  "discard",
  "distinct",
  "do",
  "drop",
  "else",
  "end",
  "except",
  "exists",
  "explain",
  "extending",
  "fetch",
  "filter",
  "for",
  "get",
  "global",
  "grant",
  "group",
  "if",
  "ilike",
  "import",
  "in",
  "insert",
  "intersect",
  "introspect",
  "is",
  "like",
  "limit",
  "listen",
  "load",
  "lock",
  "match",
  "module",
  "move",
  "never",
  "not",
  "notify",
  "offset",
  "on",
  "optional",
  "or",
  "over",
  "partition",
  "prepare",
  "raise",
  "refresh",
  "revoke",
  "rollback",
  "select",
  "set",
  "single",
  "start",
  "typeof",
  "union",
  "update",
  "variadic",
  "when",
  "window",
  "with",
];

var edgeql_keywords = reserved_keywords.concat([
  "abort",
  "abstract",
  "access",
  "after",
  "alias",
  "allow",
  "annotation",
  "applied",
  "as",
  "asc",
  "assignment",
  "before",
  "cardinality",
  "cast",
  "committed",
  "config",
  "conflict",
  "constraint",
  "cube",
  "current",
  "database",
  "ddl",
  "declare",
  "default",
  "deferrable",
  "deferred",
  "delegated",
  "deny",
  "desc",
  "each",
  "empty",
  "expression",
  "extension",
  "final",
  "first",
  "from",
  "function",
  "future",
  "implicit",
  "index",
  "infix",
  "inheritable",
  "instance",
  "into",
  "isolation",
  "json",
  "last",
  "link",
  "migration",
  "multi",
  "object",
  "of",
  "only",
  "onto",
  "operator",
  "optionality",
  "order",
  "orphan",
  "overloaded",
  "owned",
  "package",
  "policy",
  "populate",
  "postfix",
  "prefix",
  "property",
  "proposed",
  "pseudo",
  "read",
  "reject",
  "release",
  "rename",
  "required",
  "reset",
  "restrict",
  "rewrite",
  "role",
  "roles",
  "rollup",
  "savepoint",
  "scalar",
  "schema",
  "sdl",
  "serializable",
  "session",
  "source",
  "superuser",
  "system",
  "target",
  "ternary",
  "then",
  "to",
  "transaction",
  "trigger",
  "type",
  "unless",
  "using",
  "verbose",
  "version",
  "view",
  "write",
]);

var types = [
  "Base64Alphabet",
  "BaseObject",
  "ElasticLanguage",
  "FreeObject",
  "JsonEmpty",
  "Language",
  "LuceneLanguage",
  "Object",
  "PGLanguage",
  "Weight",
  "anycontiguous",
  "anydiscrete",
  "anyenum",
  "anyfloat",
  "anyint",
  "anynumeric",
  "anypoint",
  "anyreal",
  "anyscalar",
  "anytype",
  "array",
  "bigint",
  "bool",
  "bytes",
  "date_duration",
  "datetime",
  "decimal",
  "document",
  "duration",
  "enum",
  "float32",
  "float64",
  "int16",
  "int32",
  "int64",
  "json",
  "local_date",
  "local_datetime",
  "local_time",
  "multirange",
  "range",
  "relative_duration",
  "sequence",
  "str",
  "tuple",
  "uuid",
];

var common_builtins = [
  "Base64Alphabet",
  "BaseObject",
  "ElasticLanguage",
  "FreeObject",
  "JsonEmpty",
  "Language",
  "LuceneLanguage",
  "Object",
  "PGLanguage",
  "Weight",
  "anycontiguous",
  "anydiscrete",
  "anyenum",
  "anyfloat",
  "anyint",
  "anynumeric",
  "anypoint",
  "anyreal",
  "anyscalar",
  "anytype",
  "array",
  "bigint",
  "bool",
  "bytes",
  "date_duration",
  "datetime",
  "decimal",
  "document",
  "duration",
  "enum",
  "exclusive",
  "expression",
  "float32",
  "float64",
  "int16",
  "int32",
  "int64",
  "json",
  "len_value",
  "local_date",
  "local_datetime",
  "local_time",
  "max_ex_value",
  "max_len_value",
  "max_value",
  "min_ex_value",
  "min_len_value",
  "min_value",
  "multirange",
  "one_of",
  "range",
  "regexp",
  "relative_duration",
  "sequence",
  "str",
  "tuple",
  "uuid",
];

var edgeql_builtins = common_builtins.concat([
  "abs",
  "adjacent",
  "any",
  "array_agg",
  "array_fill",
  "array_get",
  "array_join",
  "array_replace",
  "array_unpack",
  "assert",
  "assert_distinct",
  "assert_exists",
  "assert_single",
  "bit_and",
  "bit_lshift",
  "bit_not",
  "bit_or",
  "bit_rshift",
  "bit_xor",
  "bounded_above",
  "bounded_below",
  "bytes_get_bit",
  "ceil",
  "contains",
  "count",
  "date_get",
  "datetime_current",
  "datetime_get",
  "datetime_of_statement",
  "datetime_of_transaction",
  "datetime_truncate",
  "duration_get",
  "duration_normalize_days",
  "duration_normalize_hours",
  "duration_to_seconds",
  "duration_truncate",
  "enumerate",
  "find",
  "floor",
  "get_current_database",
  "get_instance_name",
  "get_transaction_isolation",
  "get_version",
  "get_version_as_str",
  "json_array_unpack",
  "json_get",
  "json_object_pack",
  "json_object_unpack",
  "json_set",
  "json_typeof",
  "len",
  "lg",
  "ln",
  "log",
  "max",
  "mean",
  "min",
  "multirange_unpack",
  "overlaps",
  "random",
  "range_get_lower",
  "range_get_upper",
  "range_is_empty",
  "range_is_inclusive_lower",
  "range_is_inclusive_upper",
  "range_unpack",
  "re_match",
  "re_match_all",
  "re_replace",
  "re_test",
  "round",
  "search",
  "sequence_next",
  "sequence_reset",
  "sqrt",
  "stddev",
  "stddev_pop",
  "str_lower",
  "str_lpad",
  "str_ltrim",
  "str_pad_end",
  "str_pad_start",
  "str_repeat",
  "str_replace",
  "str_reverse",
  "str_rpad",
  "str_rtrim",
  "str_split",
  "str_title",
  "str_trim",
  "str_trim_end",
  "str_trim_start",
  "str_upper",
  "strictly_above",
  "strictly_below",
  "sum",
  "time_get",
  "to_bigint",
  "to_bytes",
  "to_date_duration",
  "to_datetime",
  "to_decimal",
  "to_duration",
  "to_float32",
  "to_float64",
  "to_int16",
  "to_int32",
  "to_int64",
  "to_json",
  "to_local_date",
  "to_local_datetime",
  "to_local_time",
  "to_relative_duration",
  "to_str",
  "uuid_generate_v1mc",
  "uuid_generate_v4",
  "var",
  "var_pop",
  "with_options",
]);

var bool_literals = [
  "false",
  "true",
];

var operators = [
  "\\!\\=",
  "\\%",
  "\\*",
  "\\+",
  "\\+\\+",
  "\\-",
  "\\/",
  "\\/\\/",
  "\\<",
  "\\<\\=",
  "\\=",
  "\\>",
  "\\>\\=",
  "\\?\\!\\=",
  "\\?\\=",
  "\\?\\?",
  "\\^",
];


var shared_grammar = {
  'comment': /#.*/,

  'string': [
      {
        // bytes
        pattern: /b(['"])(?:\\['"]|[\n\r]|.)*?\1/,
        greedy: true,
        inside: {
          'valuetype': /^b(?=['"])/,
          'escaped': [
            /\\[\\'"bfnrt]/,
            /\\x[0-9a-fA-F]{2}/,
          ],
        },
      },
      {
        // raw
        pattern: /r(['"])(?:\\['"]|[\n\r]|.)*?\1/,
        greedy: true,
        inside: {
          'valuetype': /^r(?=['"])/
        },
      },
      {
        // regular str
        pattern: /(['"])(?:\\['"]|[\n\r]|.)*?\1/,
        greedy: true,
        inside: {
          'escaped': [
            /\\(?=\s*\n)/,
            /\\[\\'"bfnrt]/,
            /\\x[0-7][0-9a-fA-F]/,
            /\\u[0-9a-fA-F]{4}/,
            /\\U[0-9a-fA-F]{8}/,
          ],
        },
      },
      {
        pattern: /(\$([A-Za-z\200-\377_][0-9]*)*\$)(?:[\n\r]|.)*?\1/,
        greedy: true,
      },
  ],

  'code': /`.+?`|\.<|\.>/,

  'number': [
    {
      pattern:
        /(\W)(\d(?:_*\d)*(?:\.\d(?:_*\d)*)?(?:[eE](?:[+\-])?\d(?:_*\d)*))n?/,
      lookbehind: true,
      inside: {
        'valuetype': /[n]/
      },
    },
    {
      pattern:
        /(\W)(\d(?:_*\d)*\.\d(?:_*\d)*)n?/,
      lookbehind: true,
      inside: {
        'valuetype': /[n]/
      },
    },
    {
      pattern: /(\W)\d(?:_*\d)*n?/,
      lookbehind: true,
      inside: {
        'valuetype': /[n]/
      },
    },
  ],

  'definition': {
    pattern: /:=|->/,
    alias: 'punctuation',
  },

  'boolean':
    RegExp('\\b(?:' + bool_literals.join('|') + ')\\b', 'i'),

  'builtin': RegExp('\\b(?:' + common_builtins.join('|') + ')\\b')
};

var shared_synopsis_grammar = {
  'synopsis-text': {
    pattern: /#([^\n]*)/,
    greedy: true,

    inside: {
      'synopsis-placeholder': /<[\w\-]+>/,
    }
  },

  'synopsis-placeholder': /<[\w\-]+>/,

  'string': {
    pattern: /(['"])(?:\\['"]|[\n\r]|.)*?\1/,
    greedy: true,
  },

  'optional': [
    /\[|\]|\{|\}/,
    /\.\.\./,
    /,/,
  ],

  'group': /[{}|]/,
}

Prism.languages.edgeql = Object.assign({}, shared_grammar, {
  'operator':
    RegExp(operators.join('|')),

  'linkprop': /@\w+/,

  'variable': /\$[\w\d]+/,

  'keyword':
    RegExp(
      '\\b(?:(?:named\\s+only)|(?:as\\s+text)|(?:all(?!\\s*\\())|' +
      edgeql_keywords.join('|') + ')\\b',
      'i'
    ),

  'builtin':
    RegExp(
      '\\b(?:(?:all(?=\\s*\\())|' +
      edgeql_builtins.join('|') + ')\\b'
    )
});

// sdl and edgeql are compatible gramamrs
Prism.languages.sdl = Prism.languages.edgeql;

Prism.languages['edgeql-synopsis'] = Object.assign({}, shared_synopsis_grammar,
{
  'keyword':
    RegExp('\\b(?:[A-Z]{2,})\\b', 'i'),

});

// sdl and edgeql are compatible gramamrs
Prism.languages['sdl-synopsis'] = Prism.languages['edgeql-synopsis'];
Prism.languages['cli-synopsis'] = Prism.languages['edgeql-synopsis'];

// eql:function signature highlighter
var func_common = {
  'type': [
    RegExp('\\b(?:' + types.join('|') + ')\\b(?!:)'),
    /\\b(?:anytype)\\b(?!:)/,
  ],
  'module-prefix': {
    pattern: /[\w]+::/,
    greedy: true,

    inside: {
      'module': /[\w]+/,
      'modseparator': /::/,
    }
  }
};
Prism.languages.eql_function = {
  'module-prefix': func_common['module-prefix'],
  'funcname': /[\w]+(?=\()/,
  'funcparams': {
    pattern: /\(.*(?=\)\s*->)/,
    greedy: true,
    inside: {
      'parenthesis': /\(/,
      'funcarg': {
        pattern: /\w[^:]*:\s[^,]*?(,\s*|$)/,
        inside: {
          'string': shared_grammar['string'],
          'number': shared_grammar['number'],
          'boolean':
            RegExp('\\b(?:' + bool_literals.join('|') + ')\\b', 'i'),

          'keyword':
            RegExp('\\b(?:variadic|named only|set of|optional)\\b', 'i'),

          'equals': /=/,

          'type': func_common['type'],
          'composite': /[<>]/,

          'module-prefix': func_common['module-prefix'],
          'argname': /[\w]+/,
        }
      }
    }
  },
  'funcreturn': {
    pattern: /\)\s*->.*/,
    greedy: true,
    inside: {
      'parenthesis': /\)/,
      'return': /->/,
      'type': func_common['type'],
      'composite': /[<>]/,
      'keyword':
        RegExp('\\b(?:variadic|named only|set of|optional)\\b', 'i'),
    }
  }
};

// eql:op signature highlighter
var op_str = {
  qual: 'variadic|named only|set of|optional',
  type: types.join('|') + '|anytype|set|to|pattern|dt|i|name|val',
};
Prism.languages.eql_operator = {
  'opdecl': {
    pattern: /[\w]+:(?!:)/,
    inside: {
      opname: /[\w]+/,
      colon: /:/,
    }
  },
  'opparam': {
    pattern: RegExp(
      '\\b((' + op_str.qual + ')\\s*)?' +
      '(' + op_str.type + '|type)\\b(\\<[^-\\s]+\\>(?=\\s))?',
      'i'
    ),
    greedy: true,
    inside: {
      'keyword':
        RegExp('\\b(?:' + op_str.qual + ')\\b', 'i'),
      'generictype': /\btype\b/,
      'type': RegExp('\\b(?:' + op_str.type + ')\\b'),
      'composite': /[<>]/,
    }
  },
  'opreturn': {
    pattern: /->.*/,
    greedy: true,
    inside: {
      'return': /->/,
      'module-prefix': func_common['module-prefix'],
      'type': func_common['type'],
      'composite': /[<>]/,
      'keyword':
        RegExp('\\b(?:' + op_str.qual + ')\\b', 'i'),
    }
  },
  'module-prefix': func_common['module-prefix'],
  'oppsymbol': /\S+/,
};
