import https from "https";
import querystring from "querystring";
import fs from "fs";
import {promisify} from "util";

import {twitterCollectionId} from "../../config";

import {generateAuthorisationHeader} from "./oauth";
import {collectionResponseSchema, v2TweetsResponseSchema} from "./schemas";
import {Tweet, User} from "../../dataSources/twitter/interfaces";

const writeFileAsync = promisify(fs.writeFile);

(async () => {
  const tweets: Tweet[] = [];
  const tweetIdMap = new Map<string, Tweet>();
  const users = new Map<string, User>();
  const truncatedTweets = new Set<string>();

  let minPosition: string | undefined = undefined;
  while (true) {
    console.log(
      `Fetching tweets in collection: ${twitterCollectionId}${
        minPosition ? `(with max_position: ${minPosition})` : ""
      } ...`
    );
    const data = collectionResponseSchema.parse(
      await fetchAPI("/1.1/collections/entries.json", {
        id: twitterCollectionId,
        count: "200",
        ...(minPosition ? {max_position: minPosition} : {}),
      })
    );

    console.log(`Fetched ${data.response.timeline.length} tweets`);

    for (const user of Object.values(data.objects.users)) {
      users.set(user.id_str, {
        id: user.id_str,
        name: user.name,
        username: user.screen_name,
        profileImageUrl: user.profile_image_url_https.replace(
          "_normal.",
          "_bigger."
        ),
      });
    }

    for (const {
      tweet: {id: tweetId},
    } of data.response.timeline) {
      const tweet = data.objects.tweets[tweetId];
      const user = users.get(tweet?.user.id_str);

      if (!tweet || !user) {
        throw new Error(`Missing data in response for tweet id: ${tweetId}`);
      }

      const newTweet: Tweet = {
        id: tweet.id_str,
        text: tweet.text,
        user: user,
        entities: {
          mentions: tweet.entities.user_mentions.map((mention) => ({
            username: mention.screen_name,
            indices: mention.indices,
          })),
          hashtags: tweet.entities.hashtags.map((hashtag) => ({
            tag: hashtag.text,
            indices: hashtag.indices,
          })),
          urls: tweet.entities.urls.map((url) => ({
            url: url.expanded_url,
            displayUrl: url.display_url,
            indices: url.indices,
          })),
        },
      };

      tweets.push(newTweet);
      tweetIdMap.set(tweet.id_str, newTweet);

      if (tweet.truncated) {
        truncatedTweets.add(tweet.id_str);
      }
    }

    minPosition = data.response.position.min_position;

    if (!data.response.position.was_truncated) {
      break;
    } else {
      console.log("More tweets in collection...");
    }
  }

  if (truncatedTweets.size > 0) {
    console.log(`\n${truncatedTweets.size} truncated tweets`);

    const truncatedIds = [...truncatedTweets.values()];
    let i = 0;
    while (i < truncatedIds.length) {
      console.log(
        `Fetching full tweet for tweets ${i + 1} to ${Math.min(
          i + 100,
          truncatedTweets.size
        )} ...`
      );
      const data = v2TweetsResponseSchema.parse(
        await fetchAPI("/2/tweets", {
          ids: truncatedIds.slice(i, i + 100).join(","),
          "tweet.fields": "entities",
        })
      );

      for (const tweetData of data.data) {
        const tweet = tweetIdMap.get(tweetData.id);

        if (!tweet) {
          throw new Error(
            `Failed to expand trunacted tweet with id: ${tweetData.id}`
          );
        }

        tweet.text = tweetData.text;
        tweet.entities = {
          mentions:
            tweetData.entities.mentions?.map((mention) => ({
              username: mention.username,
              indices: [mention.start, mention.end],
            })) ?? [],
          hashtags:
            tweetData.entities.hashtags?.map((hashtag) => ({
              tag: hashtag.tag,
              indices: [hashtag.start, hashtag.end],
            })) ?? [],
          urls:
            tweetData.entities.urls?.map((url) => ({
              url: url.expanded_url,
              displayUrl: url.display_url,
              indices: [url.start, url.end],
            })) ?? [],
        };
      }

      i += 100;
    }
  }

  console.log(`\nTotal tweets fetched: ${tweets.length}`);

  console.log('Writing tweets to "./dataSources/twitter/tweetData.js"...');
  await writeFileAsync(
    "./dataSources/twitter/tweetData.js",
    "// AUTOGENERATED FILE\n" +
      "// Re-generate file with `yarn fetchTweets`\n\n" +
      `module.exports = ${JSON.stringify(tweets, null, 2)}`
  );
  console.log("DONE!");
})();

type Params = {[key: string]: string};

async function fetchAPI(
  apiPath: string,
  queryParams?: Params,
  bodyParams?: Params,
  method = "GET"
) {
  const url = `https://api.twitter.com${apiPath}`;

  return new Promise((resolve, reject) => {
    const req = https
      .request(
        `${url}${queryParams ? "?" + querystring.encode(queryParams) : ""}`,
        {
          headers: {
            Authorization: generateAuthorisationHeader(method, url, {
              ...queryParams,
              ...bodyParams,
            }),
            ...(bodyParams
              ? {"Content-Type": "application/x-www-form-urlencoded"}
              : {}),
          },
        },
        (res) => {
          if (
            !res.statusCode ||
            res.statusCode < 200 ||
            res.statusCode >= 300
          ) {
            return reject(
              `API request failed: ${res.statusCode} ${res.statusMessage}`
            );
          }

          let data = "";
          res
            .setEncoding("utf8")
            .on("data", (chunk) => (data += chunk))
            .on("end", () => {
              resolve(JSON.parse(data));
            });
        }
      )
      .on("error", reject);

    if (bodyParams) {
      req.write(querystring.encode(bodyParams));
    }

    req.end();
  });
}
