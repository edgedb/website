#
# This source file is part of the EdgeDB open source project.
#
# Copyright 2019-present MagicStack Inc. and the EdgeDB authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#


import sys

from edb.tools.pygments.edgeql import meta


BOOL_LITERALS = ['true', 'false']
OTHER_TYPES = ['anytype']
EXCEPTION_KW = {'named', 'text', 'all'}


def main(*, stdout: bool, out_fn: str):
    code = [
        f'// AUTOGENERATED FROM edb.edgeql.parser.grammar.keywords.\n'
        f'//\n'
        f'// USE make regen-grammar TO REGENERATE\n'
        f'\n\n'
    ]

    # add common reserved keywords
    code.append(f'var reserved_keywords = [\n')
    code.extend([f'  "{kw}",\n' for kw in
                 sorted(meta.EdgeQL.reserved_keywords)])
    code.append(f'];\n\n')
    # add common edgeql-specific keywords
    code.append(f'var edgeql_keywords = reserved_keywords.concat([\n')

    unreserved_keywords = sorted(
        set(meta.EdgeQL.unreserved_keywords)
        # special keywords that have other meaning
        - EXCEPTION_KW
    )
    code.extend([f'  "{kw}",\n' for kw in unreserved_keywords])
    code.append(f']);\n\n')

    # add builtins
    types = list(meta.EdgeQL.type_builtins) + OTHER_TYPES
    types.sort()

    # NOTE: currently there's a constraint called 'std::constraint'
    # that makes it into the list and cannot be filtered out based on
    # any specific parameter.
    constraints = [kw for kw in meta.EdgeQL.constraint_builtins
                   if kw != 'constraint']

    common_builtins = types + constraints
    common_builtins.sort()

    fn_builtins = list(meta.EdgeQL.fn_builtins)
    fn_builtins.sort()

    code.append(f'var types = [\n')
    code.extend([f'  "{kw}",\n' for kw in types])
    code.append(f'];\n\n')

    code.append(f'var common_builtins = [\n')
    code.extend([f'  "{kw}",\n' for kw in common_builtins])
    code.append(f'];\n\n')

    code.append(f'var edgeql_builtins = common_builtins.concat([\n')
    code.extend([f'  "{kw}",\n' for kw in fn_builtins
                 if kw not in common_builtins and kw not in EXCEPTION_KW])
    code.append(f']);\n\n')

    # add bool literals
    code.append(f'var bool_literals = [\n')
    code.extend([f'  "{kw}",\n' for kw in meta.EdgeQL.bool_literals])
    code.append(f'];\n\n')

    # add non-word operators
    operators = list(meta.EdgeQL.operators)
    # escape every operator symbol
    operators = [R'\\' + R'\\'.join(op) for op in operators if op != ':=']
    code.append(f'var operators = [\n')
    code.extend([f'  "{kw}",\n' for kw in operators])
    code.append(f'];\n\n')

    code.append(r'''
var shared_grammar = {
  'comment': /#.*/,

  'string': [
      {
        // bytes
        pattern: /b(['"])(?:\\['"]|[\n\r]|.)*?\1/,
        greedy: true,
        inside: {
          'valuetype': /^b(?=['"])/,
          'escaped': [
            /\\[\\'"bfnrt]/,
            /\\x[0-9a-fA-F]{2}/,
          ],
        },
      },
      {
        // raw
        pattern: /r(['"])(?:\\['"]|[\n\r]|.)*?\1/,
        greedy: true,
        inside: {
          'valuetype': /^r(?=['"])/
        },
      },
      {
        // regular str
        pattern: /(['"])(?:\\['"]|[\n\r]|.)*?\1/,
        greedy: true,
        inside: {
          'escaped': [
            /\\(?=\s*\n)/,
            /\\[\\'"bfnrt]/,
            /\\x[0-7][0-9a-fA-F]/,
            /\\u[0-9a-fA-F]{4}/,
            /\\U[0-9a-fA-F]{8}/,
          ],
        },
      },
      {
        pattern: /(\$([A-Za-z\200-\377_][0-9]*)*\$)(?:[\n\r]|.)*?\1/,
        greedy: true,
      },
  ],

  'code': /`.+?`|\.<|\.>/,

  'number': [
    {
      pattern:
        /(\W)(\d(?:_*\d)*(?:\.\d(?:_*\d)*)?(?:[eE](?:[+\-])?\d(?:_*\d)*))n?/,
      lookbehind: true,
      inside: {
        'valuetype': /[n]/
      },
    },
    {
      pattern:
        /(\W)(\d(?:_*\d)*\.\d(?:_*\d)*)n?/,
      lookbehind: true,
      inside: {
        'valuetype': /[n]/
      },
    },
    {
      pattern: /(\W)\d(?:_*\d)*n?/,
      lookbehind: true,
      inside: {
        'valuetype': /[n]/
      },
    },
  ],

  'definition': {
    pattern: /:=|->/,
    alias: 'punctuation',
  },

  'boolean':
    RegExp('\\b(?:' + bool_literals.join('|') + ')\\b', 'i'),

  'builtin': RegExp('\\b(?:' + common_builtins.join('|') + ')\\b')
};

var shared_synopsis_grammar = {
  'synopsis-text': {
    pattern: /#([^\n]*)/,
    greedy: true,

    inside: {
      'synopsis-placeholder': /<[\w\-]+>/,
    }
  },

  'synopsis-placeholder': /<[\w\-]+>/,

  'string': {
    pattern: /(['"])(?:\\['"]|[\n\r]|.)*?\1/,
    greedy: true,
  },

  'optional': [
    /\[|\]|\{|\}/,
    /\.\.\./,
    /,/,
  ],

  'group': /[{}|]/,
}

Prism.languages.edgeql = Object.assign({}, shared_grammar, {
  'operator':
    RegExp(operators.join('|')),

  'linkprop': /@\w+/,

  'variable': /\$[\w\d]+/,

  'keyword':
    RegExp(
      '\\b(?:(?:named\\s+only)|(?:as\\s+text)|(?:all(?!\\s*\\())|' +
      edgeql_keywords.join('|') + ')\\b',
      'i'
    ),

  'builtin':
    RegExp(
      '\\b(?:(?:all(?=\\s*\\())|' +
      edgeql_builtins.join('|') + ')\\b'
    )
});

// sdl and edgeql are compatible gramamrs
Prism.languages.sdl = Prism.languages.edgeql;

Prism.languages['edgeql-synopsis'] = Object.assign({}, shared_synopsis_grammar,
{
  'keyword':
    RegExp('\\b(?:[A-Z]{2,})\\b', 'i'),

});

// sdl and edgeql are compatible gramamrs
Prism.languages['sdl-synopsis'] = Prism.languages['edgeql-synopsis'];
Prism.languages['cli-synopsis'] = Prism.languages['edgeql-synopsis'];

// eql:function signature highlighter
var func_common = {
  'type': [
    RegExp('\\b(?:' + types.join('|') + ')\\b(?!:)'),
    /\\b(?:anytype)\\b(?!:)/,
  ],
  'module-prefix': {
    pattern: /[\w]+::/,
    greedy: true,

    inside: {
      'module': /[\w]+/,
      'modseparator': /::/,
    }
  }
};
Prism.languages.eql_function = {
  'module-prefix': func_common['module-prefix'],
  'funcname': /[\w]+(?=\()/,
  'funcparams': {
    pattern: /\(.*(?=\)\s*->)/,
    greedy: true,
    inside: {
      'parenthesis': /\(/,
      'funcarg': {
        pattern: /\w[^:]*:\s[^,]*?(,\s*|$)/,
        inside: {
          'string': shared_grammar['string'],
          'number': shared_grammar['number'],
          'boolean':
            RegExp('\\b(?:' + bool_literals.join('|') + ')\\b', 'i'),

          'keyword':
            RegExp('\\b(?:variadic|named only|set of|optional)\\b', 'i'),

          'equals': /=/,

          'type': func_common['type'],
          'composite': /[<>]/,

          'module-prefix': func_common['module-prefix'],
          'argname': /[\w]+/,
        }
      }
    }
  },
  'funcreturn': {
    pattern: /\)\s*->.*/,
    greedy: true,
    inside: {
      'parenthesis': /\)/,
      'return': /->/,
      'type': func_common['type'],
      'composite': /[<>]/,
      'keyword':
        RegExp('\\b(?:variadic|named only|set of|optional)\\b', 'i'),
    }
  }
};

// eql:op signature highlighter
var op_str = {
  qual: 'variadic|named only|set of|optional',
  type: types.join('|') + '|anytype|set|to|pattern|dt|i|name|val',
};
Prism.languages.eql_operator = {
  'opdecl': {
    pattern: /[\w]+:(?!:)/,
    inside: {
      opname: /[\w]+/,
      colon: /:/,
    }
  },
  'opparam': {
    pattern: RegExp(
      '\\b((' + op_str.qual + ')\\s*)?' +
      '(' + op_str.type + '|type)\\b(\\<[^-\\s]+\\>(?=\\s))?',
      'i'
    ),
    greedy: true,
    inside: {
      'keyword':
        RegExp('\\b(?:' + op_str.qual + ')\\b', 'i'),
      'generictype': /\btype\b/,
      'type': RegExp('\\b(?:' + op_str.type + ')\\b'),
      'composite': /[<>]/,
    }
  },
  'opreturn': {
    pattern: /->.*/,
    greedy: true,
    inside: {
      'return': /->/,
      'module-prefix': func_common['module-prefix'],
      'type': func_common['type'],
      'composite': /[<>]/,
      'keyword':
        RegExp('\\b(?:' + op_str.qual + ')\\b', 'i'),
    }
  },
  'module-prefix': func_common['module-prefix'],
  'oppsymbol': /\S+/,
};
    '''.strip(' '))

    code = ''.join(code)

    if stdout:
        print(code, end='')
    else:
        with open(out_fn, 'wt') as f:
            f.write(code)


if __name__ == '__main__':
    if len(sys.argv) > 1:
        main(stdout=False, out_fn=sys.argv[1])
    else:
        main(stdout=True, out_fn='')
